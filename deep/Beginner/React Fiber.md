باشه حتما. در ادامه ترجمه‌ی دقیق و با جزئیات متن ارائه شده در مورد معماری فیبر ری‌اکت (React Fiber Architecture) آمده است.

---

### معماری فیبر ری‌اکت (React Fiber Architecture)

#### مقدمه
فیبر ری‌اکت (React Fiber) بازنویسی و پیاده‌سازی مجدد الگوریتم هسته‌ی اصلی ری‌اکت است. این پروژه حاصل بیش از دو سال تحقیق تیم ری‌اکت است.

هدف فیبر ری‌اکت، افزایش سازگاری آن برای حوزه‌هایی مانند انیمیشن، طرح‌بندی (layout) و حرکات اشاره (gestures) است. ویژگی اصلی آن **رندر تدریجی (incremental rendering)** است: یعنی قابلیت تقسیم کار رندر به قطعات کوچکتر و پخش کردن آن در چندین فریم.

ویژگی‌های کلیدی دیگر شامل قابلیت **متوقف کردن (pause)**، **لغو کردن (abort)** یا **استفاده مجدد (reuse)** از کار با دریافت آپدیت‌های جدید، قابلیت **تخصیص اولویت (priority)** به انواع مختلف آپدیت‌ها و همچنین مفاهیم جدید **همزمانی (concurrency)** است.

#### درباره‌ی این سند
فیبر مفاهیم جدیدی را معرفی می‌کند که درک آن‌ها تنها با نگاه کردن به کد دشوار است. این سند به عنوان مجموعه‌ای از یادداشت‌های من شروع شد که هنگام دنبال کردن پیاده‌سازی فیبر در پروژه ری‌اکت برداشته بودم. با گسترش آن، متوجه شدم که می‌تواند منبع مفیدی برای دیگران نیز باشد.

من تلاش خواهم کرد تا از ساده‌ترین زبان ممکن استفاده کنم و با تعریف صریح اصطلاحات کلیدی، از به‌کار بردن واژگان تخصصی پیچیده خودداری کنم. همچنین تا حد امکان به منابع خارجی لینک خواهم داد.

لطفاً توجه داشته باشید که من عضو تیم ری‌اکت نیستم و از هیچ جایگاه معتبری صحبت نمی‌کنم. این یک سند رسمی نیست. من از اعضای تیم ری‌اکت خواسته‌ام تا آن را برای صحت و دقت بازبینی کنند.

این سند همچنین یک **کار در حال پیشرفت (work in progress)** است. فیبر یک پروژه در حال انجام است که احتمالاً قبل از تکمیل، دستخوش بازنویسی‌های قابل توجهی خواهد شد. تلاش‌های من برای مستندسازی طراحی آن در اینجا نیز ادامه دارد. بهبودها و پیشنهادات شما بسیار مورد استقبال قرار می‌گیرد.

هدف من این است که پس از خواندن این سند، فیبر را به قدری خوب درک کنید که بتوانید روند پیاده‌سازی آن را دنبال کنید و در نهایت حتی بتوانید به ری‌اکت کمک (contribute) کنید.

#### پیش‌نیازها
من اکیداً پیشنهاد می‌کنم که قبل از ادامه، با منابع زیر آشنا باشید:

*   **کامپوننت‌ها، المنت‌ها و نمونه‌های ری‌اکت (React Components, Elements, and Instances)** - "کامپوننت" اغلب یک اصطلاح چندوجهی است. درک دقیق این اصطلاحات حیاتی است.
*   **آشتی (Reconciliation)** - توصیفی سطح بالا از الگوریتم آشتی ری‌اکت.
*   **مفاهیم نظری پایه ری‌اکت (React Basic Theoretical Concepts)** - توصیفی از مدل مفهومی ری‌اکت بدون بار پیاده‌سازی. ممکن است برخی از این موارد در خواندن اول منطقی به نظر نرسند. اشکالی ندارد، با گذشت زمان منطقی‌تر خواهند شد.
*   **اصول طراحی ری‌اکت (React Design Principles)** - به بخش مربوط به **زمان‌بندی (scheduling)** توجه ویژه داشته باشید. این بخش به خوبی **چرایی** فیبر ری‌اکت را توضیح می‌دهد.

#### بازبینی (Review)
لطفاً اگر بخش پیش‌نیازها را مطالعه نکرده‌اید، آن را بررسی کنید.

قبل از اینکه به سراغ موارد جدید برویم، بیایید چند مفهوم را مرور کنیم.

##### آشتی (reconciliation) چیست؟
**آشتی (reconciliation)**
الگوریتمی که ری‌اکت برای مقایسه (diff) یک درخت با درخت دیگر استفاده می‌کند تا مشخص کند کدام قسمت‌ها نیاز به تغییر دارند.

**آپدیت (update)**
تغییری در داده‌هایی که برای رندر کردن یک اپلیکیشن ری‌اکت استفاده می‌شود. معمولاً نتیجه‌ی `setState` است. در نهایت منجر به رندر مجدد می‌شود.

ایده اصلی API ری‌اکت این است که آپدیت‌ها را طوری در نظر بگیریم که گویی باعث رندر مجدد کل برنامه می‌شوند. این به توسعه‌دهنده اجازه می‌دهد تا به صورت **توصیفی (declaratively)** استدلال کند، به جای اینکه نگران چگونگی انتقال بهینه برنامه از یک حالت خاص به حالت دیگر باشد (از A به B، B به C، C به A و غیره).

در واقع، رندر مجدد کل برنامه در هر تغییر فقط برای برنامه‌های بسیار ساده کار می‌کند؛ در یک برنامه واقعی، این کار از نظر عملکرد بسیار پرهزینه است. ری‌اکت بهینه‌سازی‌هایی دارد که ظاهر رندر مجدد کل برنامه را ایجاد می‌کند در حالی که عملکرد عالی را حفظ می‌کند. بخش عمده‌ای از این بهینه‌سازی‌ها بخشی از فرآیندی به نام **آشتی (reconciliation)** است.

آشتی الگوریتمی است که در پس چیزی قرار دارد که عموماً به عنوان **"virtual DOM"** شناخته می‌شود. یک توصیف سطح بالا به این صورت است: وقتی شما یک برنامه ری‌اکت را رندر می‌کنید، یک درخت از نودها (nodes) که برنامه را توصیف می‌کند، تولید و در حافظه ذخیره می‌شود. این درخت سپس به محیط رندر فرستاده می‌شود — به عنوان مثال، در مورد یک برنامه مرورگر، به مجموعه‌ای از عملیات DOM ترجمه می‌شود. وقتی برنامه آپدیت می‌شود (معمولاً از طریق `setState`)، یک درخت جدید تولید می‌شود. درخت جدید با درخت قبلی مقایسه (diff) می‌شود تا مشخص شود چه عملیاتی برای به‌روزرسانی برنامه رندر شده لازم است.

اگرچه فیبر یک بازنویسی کامل از آشتی‌دهنده (reconciler) است، الگوریتم سطح بالایی که در مستندات ری‌اکت توضیح داده شده است، تا حد زیادی یکسان خواهد بود. نکات کلیدی عبارتند از:

*   فرض بر این است که انواع مختلف کامپوننت‌ها، درخت‌های کاملاً متفاوتی تولید می‌کنند. ری‌اکت تلاش نمی‌کند آن‌ها را مقایسه کند، بلکه درخت قدیمی را به طور کامل جایگزین می‌کند.
*   مقایسه لیست‌ها با استفاده از **کلیدها (keys)** انجام می‌شود. کلیدها باید "پایدار، قابل پیش‌بینی و منحصر به فرد" باشند.

##### آشتی در مقابل رندر (Reconciliation versus rendering)
DOM تنها یکی از محیط‌های رندری است که ری‌اکت می‌تواند به آن رندر کند؛ اهداف اصلی دیگر، نماهای نیتیو iOS و Android از طریق React Native هستند. (به همین دلیل است که "virtual DOM" کمی نام اشتباهی است.)

دلیل اینکه ری‌اکت می‌تواند از این همه هدف پشتیبانی کند این است که طوری طراحی شده که **آشتی** و **رندر** فازهای جداگانه‌ای هستند. آشتی‌دهنده کار محاسبه اینکه کدام بخش‌های یک درخت تغییر کرده‌اند را انجام می‌دهد؛ سپس رندرکننده (renderer) از آن اطلاعات برای به‌روزرسانی واقعی برنامه رندر شده استفاده می‌کند.

این جداسازی به این معنی است که React DOM و React Native می‌توانند از رندرکننده‌های خود استفاده کنند در حالی که از همان آشتی‌دهنده‌ی ارائه شده توسط هسته ری‌اکت به طور مشترک استفاده می‌کنند.

**فیبر، آشتی‌دهنده را دوباره پیاده‌سازی می‌کند.** این موضوع اصولاً به رندرینگ مربوط نمی‌شود، اگرچه رندرکننده‌ها باید برای پشتیبانی (و بهره‌برداری) از معماری جدید تغییر کنند.

##### زمان‌بندی (Scheduling)
**زمان‌بندی (scheduling)**
فرآیند تعیین اینکه چه زمانی کار باید انجام شود.

**کار (work)**
هرگونه محاسباتی که باید انجام شود. کار معمولاً نتیجه یک آپدیت است (مثلاً `setState`).

سند اصول طراحی ری‌اکت در این مورد آنقدر خوب است که من فقط آن را نقل قول می‌کنم:

> در پیاده‌سازی فعلی، ری‌اکت به صورت بازگشتی (recursively) درخت را پیمایش می‌کند و توابع رندر کل درخت آپدیت شده را در یک تیک (tick) فراخوانی می‌کند. با این حال، در آینده ممکن است برخی از آپدیت‌ها را به تأخیر بیندازد تا از افت فریم جلوگیری کند.
>
> این یک موضوع رایج در طراحی ری‌اکت است. برخی از کتابخانه‌های محبوب، رویکرد **"push"** را پیاده‌سازی می‌کنند که در آن محاسبات زمانی انجام می‌شود که داده‌های جدید در دسترس باشند. با این حال، ری‌اکت به رویکرد **"pull"** پایبند است که در آن محاسبات می‌توانند تا زمان نیاز به تأخیر بیفتند.
>
> ری‌اکت یک کتابخانه پردازش داده عمومی نیست. این یک کتابخانه برای ساخت رابط‌های کاربری است. ما فکر می‌کنیم که به طور منحصر به فردی در یک برنامه قرار گرفته است تا بداند کدام محاسبات در حال حاضر مرتبط هستند و کدام نیستند.
>
> اگر چیزی خارج از صفحه باشد، می‌توانیم هر منطقی مربوط به آن را به تأخیر بیندازیم. اگر داده‌ها سریع‌تر از نرخ فریم می‌رسند، می‌توانیم آپدیت‌ها را ادغام و دسته‌بندی کنیم. ما می‌توانیم کاری که از تعاملات کاربر ناشی می‌شود (مانند انیمیشن ناشی از کلیک روی دکمه) را بر کار پس‌زمینه کم‌اهمیت‌تر (مانند رندر محتوای جدیدی که به تازگی از شبکه بارگیری شده) اولویت‌بندی کنیم تا از افت فریم جلوگیری کنیم.

نکات کلیدی عبارتند از:

*   در یک UI، لازم نیست هر آپدیت فوراً اعمال شود؛ در واقع، انجام این کار می‌تواند بیهوده باشد، باعث افت فریم و کاهش تجربه کاربری شود.
*   انواع مختلف آپدیت‌ها اولویت‌های متفاوتی دارند — یک آپدیت انیمیشن باید سریع‌تر از، مثلاً، یک آپدیت از یک منبع داده تکمیل شود.
*   یک رویکرد مبتنی بر push مستلزم آن است که برنامه (شما، برنامه‌نویس) تصمیم بگیرد که چگونه کار را زمان‌بندی کند. یک رویکرد مبتنی بر pull به فریمورک (ری‌اکت) اجازه می‌دهد هوشمند باشد و آن تصمیمات را برای شما بگیرد.

ری‌اکت در حال حاضر به طور قابل توجهی از زمان‌بندی بهره نمی‌برد؛ یک آپدیت منجر به رندر مجدد فوری کل زیردرخت می‌شود. بازنگری الگوریتم هسته ری‌اکت برای بهره‌برداری از زمان‌بندی، ایده محرک پشت فیبر است.

حالا آماده‌ایم تا به پیاده‌سازی فیبر بپردازیم. بخش بعدی فنی‌تر از آن چیزی است که تاکنون بحث کرده‌ایم. لطفاً قبل از ادامه، مطمئن شوید که با مطالب قبلی راحت هستید.

#### فیبر (fiber) چیست؟
ما در آستانه بحث در مورد قلب معماری فیبر ری‌اکت هستیم. فیبرها یک انتزاع (abstraction) بسیار سطح پایین‌تر از آن چیزی هستند که توسعه‌دهندگان برنامه معمولاً به آن فکر می‌کنند. اگر در تلاش برای درک آن ناامید شدید، دلسرد نشوید. به تلاش ادامه دهید و در نهایت منطقی خواهد شد. (وقتی بالاخره آن را فهمیدید، لطفاً پیشنهاد دهید که چگونه این بخش را بهبود ببخشم.)

بسیار خب، شروع می‌کنیم!

ما مشخص کردیم که هدف اصلی فیبر این است که ری‌اکت بتواند از زمان‌بندی بهره ببرد. به طور خاص، ما باید بتوانیم:

*   کار را متوقف کرده و بعداً به آن بازگردیم.
*   به انواع مختلف کار اولویت اختصاص دهیم.
*   از کار قبلاً تکمیل شده دوباره استفاده کنیم.
*   اگر کاری دیگر مورد نیاز نیست، آن را لغو کنیم.

برای انجام هر یک از این موارد، ابتدا به راهی برای تقسیم کار به **واحدهای کوچکتر** نیاز داریم. به یک معنا، این همان کاری است که یک فیبر انجام می‌دهد. **یک فیبر نشان‌دهنده یک واحد کار (unit of work) است.**

برای پیشروی بیشتر، بیایید به مفهوم کامپوننت‌های ری‌اکت به عنوان توابعی از داده‌ها بازگردیم، که معمولاً به صورت زیر بیان می‌شود:

`v = f(d)`

از این رو، رندر کردن یک برنامه ری‌اکت شبیه به فراخوانی یک تابع است که بدنه آن شامل فراخوانی توابع دیگر و غیره است. این قیاس هنگام فکر کردن به فیبرها مفید است.

روشی که کامپیوترها معمولاً اجرای یک برنامه را ردیابی می‌کنند، استفاده از **پشته فراخوانی (call stack)** است. هنگامی که یک تابع اجرا می‌شود، یک **فریم پشته (stack frame)** جدید به پشته اضافه می‌شود. آن فریم پشته نشان‌دهنده کاری است که توسط آن تابع انجام می‌شود.

هنگام کار با UIها، مشکل این است که اگر کار بیش از حد به یکباره اجرا شود، می‌تواند باعث افت فریم و بریده بریده شدن انیمیشن‌ها شود. علاوه بر این، بخشی از آن کار ممکن است غیرضروری باشد اگر توسط یک آپدیت جدیدتر جایگزین شود. اینجاست که مقایسه بین کامپوننت‌های UI و توابع به طور کلی از هم می‌پاشد، زیرا کامپوننت‌ها دغدغه‌های خاص‌تری نسبت به توابع عمومی دارند.

مرورگرهای جدیدتر (و React Native) APIهایی را پیاده‌سازی می‌کنند که به حل دقیقاً همین مشکل کمک می‌کنند: `requestIdleCallback` یک تابع با اولویت پایین را زمان‌بندی می‌کند تا در یک دوره بیکاری فراخوانی شود، و `requestAnimationFrame` یک تابع با اولویت بالا را زمان‌بندی می‌کند تا در فریم انیمیشن بعدی فراخوانی شود. مشکل این است که برای استفاده از آن APIها، به راهی برای تقسیم کار رندر به واحدهای تدریجی نیاز دارید. اگر فقط به پشته فراخوانی تکیه کنید، تا زمانی که پشته خالی شود به کار خود ادامه خواهد داد.

آیا عالی نمی‌شد اگر می‌توانستیم رفتار پشته فراخوانی را برای بهینه‌سازی رندر UIها سفارشی کنیم؟ آیا عالی نمی‌شد اگر می‌توانستیم پشته فراخوانی را به دلخواه قطع کنیم و فریم‌های پشته را به صورت دستی دستکاری کنیم؟

**این هدف فیبر ری‌اکت است.** فیبر، پیاده‌سازی مجدد پشته است که برای کامپوننت‌های ری‌اکت تخصصی شده است. شما می‌توانید یک فیبر واحد را به عنوان یک **فریم پشته مجازی (virtual stack frame)** در نظر بگیرید.

مزیت پیاده‌سازی مجدد پشته این است که می‌توانید فریم‌های پشته را در حافظه نگه دارید و آنها را هر طور (و هر زمان) که بخواهید اجرا کنید. این برای دستیابی به اهدافی که برای زمان‌بندی داریم، حیاتی است.

علاوه بر زمان‌بندی، کار دستی با فریم‌های پشته، پتانسیل ویژگی‌هایی مانند **همزمانی (concurrency)** و **مرزهای خطا (error boundaries)** را باز می‌کند. ما این موضوعات را در بخش‌های آینده پوشش خواهیم داد.

در بخش بعدی، بیشتر به ساختار یک فیبر نگاه خواهیم کرد.

#### ساختار یک فیبر (Structure of a fiber)
*توجه: هرچه در مورد جزئیات پیاده‌سازی خاص‌تر می‌شویم، احتمال تغییر چیزی افزایش می‌یابد. لطفاً در صورت مشاهده هرگونه اشتباه یا اطلاعات قدیمی، یک PR ثبت کنید.*

به طور مشخص، یک فیبر یک شیء جاوااسکریپت است که حاوی اطلاعاتی در مورد یک کامپوننت، ورودی آن و خروجی آن است.

**یک فیبر هم با یک فریم پشته مطابقت دارد و هم با یک نمونه (instance) از یک کامپوننت.**

در اینجا برخی از فیلدهای مهمی که به یک فیبر تعلق دارند، آورده شده است. (این لیست جامع نیست.)

##### `type` و `key`
`type` و `key` یک فیبر همان هدفی را دارند که برای المنت‌های ری‌اکت دارند. (در واقع، هنگامی که یک فیبر از یک المنت ایجاد می‌شود، این دو فیلد مستقیماً کپی می‌شوند.)

`type` یک فیبر، کامپوننتی را که به آن مربوط می‌شود توصیف می‌کند. برای کامپوننت‌های ترکیبی (composite components)، `type` خود تابع یا کلاس کامپوننت است. برای کامپوننت‌های میزبان (host components) (مانند `div`, `span` و غیره)، `type` یک رشته است.

به طور مفهومی، `type` همان تابعی است (مانند `v = f(d)`) که اجرای آن توسط فریم پشته ردیابی می‌شود.

همراه با `type`، از `key` در طول آشتی برای تعیین اینکه آیا فیبر می‌تواند دوباره استفاده شود یا نه، استفاده می‌شود.

##### `child` و `sibling`
این فیلدها به فیبرهای دیگر اشاره می‌کنند و ساختار درختی بازگشتی یک فیبر را توصیف می‌کنند.

فیبر `child` با مقداری که توسط متد `render` یک کامپوننت برگردانده می‌شود، مطابقت دارد. بنابراین در مثال زیر:
```jsx
function Parent() {
  return <Child />
}
```
فیبر `child` از `Parent` با `Child` مطابقت دارد.

فیلد `sibling` حالتی را پوشش می‌دهد که `render` چندین فرزند را برمی‌گرداند (یک ویژگی جدید در فیبر!):
```jsx
function Parent() {
  return [<Child1 />, <Child2 />]
}
```
فیبرهای فرزند یک لیست پیوندی یک‌طرفه (singly-linked list) را تشکیل می‌دهند که رأس آن اولین فرزند است. بنابراین در این مثال، `child` از `Parent` برابر `Child1` و `sibling` از `Child1` برابر `Child2` است.

با بازگشت به قیاس تابع ما، می‌توانید یک فیبر فرزند را به عنوان یک **تابع فراخوانی شده در انتها (tail-called function)** در نظر بگیرید.

##### `return`
فیبر `return` فیبری است که برنامه باید پس از پردازش فیبر فعلی به آن بازگردد. از نظر مفهومی، همان **آدرس بازگشت (return address)** یک فریم پشته است. همچنین می‌توان آن را به عنوان **فیبر والد (parent fiber)** در نظر گرفت.

اگر یک فیبر چندین فیبر فرزند داشته باشد، فیبر `return` هر فیبر فرزند، والد است. بنابراین در مثال ما در بخش قبل، فیبر `return` برای `Child1` و `Child2` همان `Parent` است.

##### `pendingProps` و `memoizedProps`
به طور مفهومی، `props` آرگومان‌های یک تابع هستند. `pendingProps` یک فیبر در ابتدای اجرای آن تنظیم می‌شود و `memoizedProps` در انتهای آن.

هنگامی که `pendingProps` ورودی با `memoizedProps` برابر باشد، این نشان می‌دهد که خروجی قبلی فیبر می‌تواند دوباره استفاده شود و از کار غیرضروری جلوگیری می‌کند.

##### `pendingWorkPriority`
عددی که اولویت کار ارائه شده توسط فیبر را نشان می‌دهد. ماژول `ReactPriorityLevel` سطوح مختلف اولویت و معنای آنها را لیست می‌کند.

به استثنای `NoWork` که 0 است، عدد بزرگتر نشان‌دهنده اولویت پایین‌تر است. به عنوان مثال، می‌توانید از تابع زیر برای بررسی اینکه آیا اولویت یک فیبر حداقل به اندازه سطح داده شده بالا است یا خیر، استفاده کنید:
```javascript
function matchesPriority(fiber, priority) {
  return fiber.pendingWorkPriority !== 0 &&
         fiber.pendingWorkPriority <= priority
}
```
این تابع فقط برای توضیح است؛ در واقع بخشی از کدبیس فیبر ری‌اکت نیست.

زمان‌بند (scheduler) از فیلد اولویت برای جستجوی واحد کار بعدی برای انجام استفاده می‌کند. این الگوریتم در بخش آینده مورد بحث قرار خواهد گرفت.

##### `alternate`
**flush**
`flush` کردن یک فیبر به معنای رندر کردن خروجی آن بر روی صفحه است.

**work-in-progress (کار در حال انجام)**
فیبری که هنوز تکمیل نشده است؛ به طور مفهومی، یک فریم پشته که هنوز بازنگشته است.

در هر زمان، یک نمونه کامپوننت حداکثر دو فیبر دارد که با آن مطابقت دارند: فیبر **فعلی (current)** و `flush` شده، و فیبر **در حال انجام کار (work-in-progress)**.

`alternate` فیبر فعلی، فیبر در حال انجام کار است و `alternate` فیبر در حال انجام کار، فیبر فعلی است.

`alternate` یک فیبر به صورت تنبل (lazily) با استفاده از تابعی به نام `cloneFiber` ایجاد می‌شود. به جای اینکه همیشه یک شیء جدید ایجاد کند، `cloneFiber` تلاش می‌کند تا در صورت وجود، از `alternate` فیبر دوباره استفاده کند و تخصیص حافظه را به حداقل برساند.

شما باید فیلد `alternate` را به عنوان یک جزئیات پیاده‌سازی در نظر بگیرید، اما آنقدر در کدبیس ظاهر می‌شود که بحث در مورد آن در اینجا ارزشمند است.

##### `output`
**host component (کامپوننت میزبان)**
نودهای برگ (leaf nodes) یک برنامه ری‌اکت. آنها مختص محیط رندر هستند (به عنوان مثال، در یک برنامه مرورگر، آنها `div`، `span` و غیره هستند). در JSX، آنها با نام‌های تگ با حروف کوچک مشخص می‌شوند.

به طور مفهومی، **خروجی (output)** یک فیبر، مقدار بازگشتی یک تابع است.

هر فیبر در نهایت خروجی دارد، اما خروجی فقط در نودهای برگ توسط **کامپوننت‌های میزبان** ایجاد می‌شود. سپس خروجی به سمت بالای درخت منتقل می‌شود.

خروجی چیزی است که در نهایت به رندرکننده داده می‌شود تا بتواند تغییرات را به محیط رندر `flush` کند. این مسئولیت رندرکننده است که تعریف کند خروجی چگونه ایجاد و به‌روز می‌شود.

#### بخش‌های آینده
این تمام چیزی است که در حال حاضر وجود دارد، اما این سند به هیچ وجه کامل نیست. بخش‌های آینده الگوریتم‌های مورد استفاده در طول چرخه حیات یک آپدیت را توصیف خواهند کرد. موضوعاتی که باید پوشش داده شوند عبارتند از:

*   چگونه زمان‌بند واحد کار بعدی را برای انجام پیدا می‌کند.
*   چگونه اولویت در سراسر درخت فیبر ردیابی و منتشر می‌شود.
*   چگونه زمان‌بند می‌داند چه زمانی کار را متوقف و از سر بگیرد.
*   چگونه کار `flush` و به عنوان تکمیل شده علامت‌گذاری می‌شود.
*   چگونه عوارض جانبی (side-effects) (مانند متدهای چرخه حیات) کار می‌کنند.
*   یک کوروتین (coroutine) چیست و چگونه می‌توان از آن برای پیاده‌سازی ویژگی‌هایی مانند context و layout استفاده کرد.
