داستان React 18: چرا این یک انقلاب بود؟
بیایید این داستان را به زبانی ساده و خودمانی تعریف کنیم. داستان React 18 خیلی جذاب‌تر از چیزی است که به نظر می‌رسد!

تصور کنید تیم ری‌اکت حدود ۶ سال زمان صرف کرد تا نسخه ۱۸ را منتشر کند. در ابتدا، خیلی‌ها فکر می‌کردند: «این‌ها یک سری قابلیت پیچیده است که فقط به درد توسعه‌دهندگان کتابخانه‌ها می‌خورد.» اما در واقع، این آپدیت یک انقلاب بود.

خب، مشکل اصلی چه بود؟ مشکل خودِ ری‌اکت نبود، بلکه جاوا اسکریپت بود.

در مرورگر، همه‌چیز (کدهای جاوا اسکریپت، کلیک‌های ما، نمایش محتوا روی صفحه) در یک صف یا نخ (Thread) واحد اتفاق می‌افتد. این را مثل یک جاده‌ی یک‌بانده در نظر بگیرید. 🛣️

حالا فرض کنید ری‌اکت مشغول رندر کردن یک لیست خیلی بزرگ و سنگین است (مثلاً لیستی از هزاران کارمند). اگر شما دقیقاً در همان لحظه سعی کنید چیزی در یک کادر جستجو تایپ کنید، تایپ شما با تأخیر و لگ نمایش داده می‌شود، چون جاده مشغول است. اپلیکیشن به شدت کند و آزاردهنده به نظر می‌رسد. 😫

راه‌حل ری‌اکت: جادویی به نام "Concurrency"
تیم ری‌اکت یک ایده‌ی درخشان ارائه داد. آن‌ها گفتند به جای اینکه کارها را به یک جاده‌ی دیگر منتقل کنیم (که پیچیدگی‌های خودش را دارد)، بیایید همین جاده‌ی تک‌بانده را هوشمندتر کنیم!

ایده این بود: به ری‌اکت یاد بدهیم که بین وظایف مختلف تفاوت قائل شود.

کارهای با اولویت بالا (فوری): چیزهایی مثل تایپ کردن کاربر، کلیک‌ها یا انیمیشن‌ها. (این‌ها باید فوراً انجام شوند) 🏎️

کارهای با اولویت پایین (غیرفوری): چیزهایی مثل رندر کردن آن لیست سنگین هزار نفره. (این‌ها می‌توانند کمی صبر کنند) 🐢

ری‌اکت ۱۸ این قابلیت را پیدا کرد که بتواند یک کار سنگین با اولویت پایین را در میانه‌ی کار متوقف کند، برود کار فوری و مهم کاربر را انجام دهد و سپس برگردد و ادامه‌ی کار قبلی را تمام کند. به این ترتیب، اپلیکیشن همیشه پاسخگو (Responsive) باقی می‌ماند و کاربر هیچ کندی‌ای احساس نمی‌کند.

ابزارهای جدید ما: useDeferredValue و useTransition
برای اینکه بتوانیم از این قابلیت فوق‌العاده استفاده کنیم، ری‌اکت دو ابزار اصلی به ما داد:

۱. useDeferredValue: «این یکی عجله‌ای نداره!»
این هوک (Hook) مثل این است که به ری‌اکت بگویید: «هی، این مقدار (مثلاً متنی که کاربر تایپ می‌کند) قرار است یک لیست سنگین را آپدیت کند. لطفاً به‌روزرسانی با این مقدار را به تعویق بینداز.»

چطور کار می‌کند؟
تصور کنید کاربر در حال تایپ سریع برای جستجو در همان لیست کارمندان است.

وظیفه فوری: نمایش حروفی که کاربر در کادر جستجو تایپ می‌کند.

وظیفه غیرفوری: آپدیت کردن لیست بزرگ کارمندان بر اساس آن حروف.

useDeferredValue می‌گوید: «اول کار فوری را انجام بده (تایپ را نشان بده). وقتی سرت خلوت شد و کاربر دست از تایپ کشید، آن‌وقت برو و لیست سنگین را با مقدار نهایی آپدیت کن.»

به این شکل، صفحه در حین تایپ کاربر فریز نمی‌شود.

۲. useTransition: «مواظب باش، این آپدیت سنگینه!»
این یکی کمی مستقیم‌تر عمل می‌کند. شما از آن برای نشانه‌گذاری یک بخش از کدتان (به‌طور خاص فراخوانی‌های setState) استفاده می‌کنید و به ری‌اکت می‌گویید: «رفیق، این آپدیتی که می‌خواهم انجام دهم ممکن است کند باشد. لطفاً موقع انجام دادنش، رابط کاربری (UI) را مسدود نکن.»

چطور کار می‌کند؟
فرض کنید چند تب دارید. یکی از تب‌ها ("گزارشات سنگین") برای لود شدن زمان زیادی می‌برد. اگر کاربر روی آن تب کلیک کند و بلافاصله روی یک تب سبک‌تر ("پروفایل") کلیک کند:

بدون useTransition: ری‌اکت درگیر لود کردن تب سنگین می‌شود و تا کارش تمام نشود، تب پروفایل را نشان نمی‌دهد.

با useTransition: ری‌اکت می‌فهمد که لود کردن تب سنگین یک "Transition" است. پس اگر کاربر وسط کار روی تب پروفایل کلیک کند، ری‌اکت می‌گوید: «اوکی، یک کار مهم‌تر پیش آمد!» لود تب سنگین را متوقف می‌کند، سریع تب پروفایل را نشان می‌دهد و بعد با خیال راحت برمی‌گردد تا لود تب سنگین را تمام کند.

یک قابلیت باحال اضافه ✨
هوک useTransition یک متغیر به نام isPending هم در اختیار شما قرار می‌دهد. این متغیر تا زمانی که آن کار سنگین در حال اجراست، true باقی می‌ماند. با این متغیر می‌توانید به راحتی به کاربر چیزی مثل "در حال بارگذاری..." یا یک اسپینر نشان دهید تا بداند اپلیکیشن هنگ نکرده، فقط مشغول انجام یک کار سنگین است!

جمع‌بندی
کل داستان این است که React 18 با این ابزارها، این قدرت را به ما داد تا اپلیکیشن‌های روان‌تر و سریع‌تری بسازیم، به‌خصوص برای کاربرانی که دستگاه‌های ضعیف‌تری دارند. این آپدیت درباره بهبود تجربه کاربری (UX) با جلوگیری از مسدود شدن UI بود.
