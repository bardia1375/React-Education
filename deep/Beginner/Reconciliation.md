
باشه حتما! با کمال میل این متن فوق‌العاده رو به یک فارسی خودمونی، مدرن و روان ترجمه می‌کنم تا تمام جزئیاتش رو با هم یاد بگیریم. بزن بریم!

---

### **آشتی یا Reconciliation در ری‌اکت: موتور پنهانی که کامپوننت‌های شما را می‌گرداند**

*۸ آوریل ۲۰۲۵ - ۱۲ دقیقه مطالعه*
*ری‌اکت • پرفورمنس • معماری • معماری پاک • تایپ‌اسکریپت*

> **یک آپدیت سریع:** موقع ساده‌سازی یه مثال پیچیده قبل از انتشار، یه سری جزئیات رو اشتباهی نوشتم. خیلی ممنونم از بازخورد خواننده‌ها که اینو بهم گفتن، واقعاً لطف کردید! یه لینک داخلی هم خراب بود که اونم درست شد. بازم ممنون 🙏

### موتور آشتی (The Reconciliation Engine)

توی مقاله‌های قبلی‌م ([۱](https://example.com), [۲](https://example.com))، در مورد `React.memo` و روش‌های هوشمندانه‌تر برای بهینه‌سازی پرفورمنس با استفاده از کامپوزیشن (ترکیب کامپوننت‌ها) صحبت کردم. اما برای اینکه واقعاً استاد بهینه‌سازی پرفورمنس توی ری‌اکت بشیم، باید موتوری که همه چیز رو راه میندازه رو بشناسیم: **الگوریتم آشتی یا Reconciliation ری‌اکت.**

**Reconciliation** پروسه‌ایه که ری‌اکت با استفاده از اون، DOM رو آپدیت می‌کنه تا با درخت کامپوننت‌های شما هماهنگ بشه. این همون چیزیه که مدل برنامه‌نویسی اعلانی (declarative) ری‌اکت رو ممکن می‌کنه - شما فقط توصیف می‌کنید که چی می‌خواید، و ری‌اکت خودش کشف می‌کنه که چطور به بهینه‌ترین شکل ممکن اون رو اجرا کنه.

### هویت کامپوننت و ماندگاری استِیت (State)

قبل از اینکه شیرجه بزنیم تو جزئیات فنی، بیاید یه رفتار جالب رو بررسی کنیم که نشون میده ری‌اکت چطور به «هویت» یک کامپوننت نگاه می‌کنه.

این مثال ساده از یه فرم با یک فیلد متنی که بین دو حالت تغییر می‌کنه رو در نظر بگیرید:

```javascript
const UserInfoForm = () => {
  const [isEditing, setIsEditing] = useState(false);

  return (
    <div className="form-container">
      <button onClick={() => setIsEditing(!isEditing)}>
        {isEditing ? "Cancel" : "Edit"}
      </button>

      {isEditing ? (
        <input
          type="text"
          placeholder="Enter your name"
          className="edit-input"
        />
      ) : (
        <input
          type="text"
          placeholder="Enter your name"
          disabled
          className="view-input"
        />
      )}
    </div>
  );
};
```

رفتار جالب وقتی اتفاق میفته که با این فرم کار می‌کنید. اگه تو حالت ادیت یه چیزی تایپ کنید و بعد دکمه "Cancel" رو بزنید، وقتی دوباره روی "Edit" کلیک کنید، **متنی که تایپ کرده بودید هنوز سر جاشه!** این اتفاق با اینکه دو تا المنت `input` ما پراپ‌های (props) متفاوتی دارن (یکیش `disabled` هست و کلاس متفاوتی داره) باز هم میفته.

دلیلش اینه که ری‌اکت المنت DOM و استیت (state) اون رو حفظ می‌کنه، چون هر دو المنت از **یک نوع** (`input`) هستن و **در یک موقعیت** در درخت المنت‌ها قرار دارن. ری‌اکت به جای اینکه یه المنت جدید بسازه، فقط پراپ‌های المنت موجود رو آپدیت می‌کنه.

اما اگه کدمون رو اینطوری تغییر می‌دادیم:

```javascript
{
  isEditing ? (
    <input type="text" placeholder="Enter your name" className="edit-input" />
  ) : (
    <div className="view-only-display">Name will appear here</div>
  );
}
```

اونوقت با تغییر حالت ادیت، المنت‌ها کاملاً متفاوت می‌شدن (`input` در برابر `div`) و در نتیجه، ری‌اکت المنت قبلی رو از بین می‌برد (unmount) و یه المنت جدید رو می‌ساخت (mount) و هرچیزی که کاربر تایپ کرده بود از بین می‌رفت.

این رفتار، یکی از جنبه‌های بنیادین Reconciliation ری‌اکت رو نشون میده: **نوع المنت، فاکتور اصلی در تعیین هویتشه.** فهمیدن این مفهوم، کلید استادی در پرفورمنس ری‌اکته.

### درخت المنت‌ها، نه Virtual DOM

احتمالاً شنیدید که ری‌اکت از یه چیزی به اسم «Virtual DOM» (دام مجازی) برای بهینه‌سازی آپدیت‌ها استفاده می‌کنه. با اینکه این یه مدل ذهنی مفیده، اما دقیق‌تر اینه که به نمایش داخلی ری‌اکت به عنوان یک **درخت المنت (element tree)** نگاه کنیم - یک توصیف سبک از چیزی که باید روی صفحه نمایش داده بشه.

وقتی شما یه JSX مثل این می‌نویسید:

```jsx
const Component = () => {
  return (
    <div>
      <h1>Hello</h1>
      <p>World</p>
    </div>
  );
};
```

ری‌اکت اون رو به درختی از آبجکت‌های ساده جاوااسکریپت تبدیل می‌کنه:

```json
{
  "type": "div",
  "props": {
    "children": [
      {
        "type": "h1",
        "props": {
          "children": "Hello"
        }
      },
      {
        "type": "p",
        "props": {
          "children": "World"
        }
      }
    ]
  }
}
```

برای المنت‌های DOM مثل `div` یا `input`، مقدار `type` یک رشته (string) است. اما برای کامپوننت‌های سفارشی ری‌اکت، `type` به خود **تابع کامپوننت** اشاره می‌کنه:

```json
{
  "type": Input, // ارجاع به خود تابع Input
  "props": {
    "id": "company-tax-id",
    "placeholder": "Enter company Tax ID"
  }
}
```

### Reconciliation چطور کار می‌کنه؟

وقتی ری‌اکت نیاز به آپدیت UI داره (بعد از تغییر state یا یک رندر مجدد)، این کارها رو انجام میده:

1.  با فراخوانی کامپوننت‌های شما، یک **درخت المنت جدید** می‌سازه.
2.  اون رو با درخت **قبلی** مقایسه می‌کنه.
3.  کشف می‌کنه که چه عملیات DOMای لازمه تا DOM واقعی با درخت جدید هماهنگ بشه.
4.  اون عملیات رو به صورت بهینه اجرا می‌کنه.

الگوریتم مقایسه از این اصول کلیدی پیروی می‌کنه:

#### ۱. نوع المنت، هویت رو تعیین می‌کنه

ری‌اکت اول `type` المنت‌ها رو چک می‌کنه. اگه نوعشون تغییر کنه، ری‌اکت **کل اون زیردرخت رو از نو می‌سازه**:

```jsx
// از این (رندر اول)
<div>
  <Counter />
</div>

// به این (رندر دوم)
<span>
  <Counter />
</span>
```

چون `div` به `span` تغییر کرده، ری‌اکت کل درخت قدیمی (شامل کامپوننت `Counter`) رو نابود می‌کنه و یه درخت کاملاً جدید از صفر می‌سازه.

#### ۲. موقعیت در درخت مهمه

الگوریتم Reconciliation ری‌اکت به شدت به موقعیت کامپوننت در ساختار درخت وابسته است. موقعیت به عنوان یک شناسه اصلی هویت در طول پروسه مقایسه (diffing) عمل می‌کنه.

```jsx
// فرض کنیم showDetails برابر true است: UserProfile رندر میشه
<>
  {showDetails ? <UserProfile userId={123} /> : <LoginPrompt />}
</>

// حالا فرض کنیم showDetails برابر false است: LoginPrompt رندر میشه
<>
  {showDetails ? <UserProfile userId={123} /> : <LoginPrompt />}
</>
```

در این مثال شرطی، ری‌اکت به اولین جایگاه فرزند در این فرگمنت (`<>`) به عنوان یک «اسلات» یا جایگاه واحد نگاه می‌کنه. وقتی `showDetails` از `true` به `false` تغییر می‌کنه، ری‌اکت می‌بینه که نوع کامپوننت در اون موقعیت تغییر کرده (`UserProfile` در مقابل `LoginPrompt`). چون نوع کامپوننت در جایگاه اول عوض شده، ری‌اکت کامپوننت قبلی رو به طور کامل از بین می‌بره (unmount) (با تمام استیت‌هاش) و کامپوننت جدید رو سوار می‌کنه (mount).

این هویت مبتنی بر موقعیت، توضیح میده که چرا در موارد ساده‌تر، کامپوننت‌ها استیت خودشون رو حفظ می‌کنن:

```jsx
// قبل
<>
  {isPrimary ? (
    <UserProfile userId={123} role="primary" />
  ) : (
    <UserProfile userId={456} role="secondary" />
  )}
</>
```

اینجا، فارغ از مقدار `isPrimary`، ری‌اکت **همون نوع کامپوننت** (`UserProfile`) رو در **همون موقعیت** می‌بینه. در نتیجه، نمونه کامپوننت رو حفظ می‌کنه و به جای اینکه اون رو از نو بسازه، فقط پراپ‌هاش رو آپدیت می‌کنه.

این رویکرد مبتنی بر موقعیت برای اکثر سناریوها خوب کار می‌کنه، اما وقتی مشکل‌ساز میشه که:
*   موقعیت کامپوننت‌ها به صورت داینامیک تغییر کنه (مثل لیست‌های مرتب‌شده).
*   شما نیاز داشته باشید استیت رو موقع جابجایی کامپوننت‌ها بین موقعیت‌های مختلف حفظ کنید.
*   شما بخواید دقیقاً کنترل کنید که کامپوننت‌ها کی باید از نو ساخته بشن.

اینجاست که سیستم `key` در ری‌اکت وارد میدان میشه.

#### ۳. `key` ها مقایسه مبتنی بر موقعیت رو نادیده می‌گیرن

اتریبیوت `key` به توسعه‌دهنده‌ها کنترل صریح روی هویت کامپوننت میده و شناسایی پیش‌فرض مبتنی بر موقعیت ری‌اکت رو لغو می‌کنه. `key` به ری‌اکت میگه: «هی، کاری به موقعیت این کامپوننت نداشته باش، هویتش این کلید منحصر به فرده!»

### جادوی `key` ها

`key` ها بیشتر به خاطر نقششون در لیست‌ها شناخته میشن، اما تاثیرات عمیق‌تری روی پروسه Reconciliation ری‌اکت دارن.

#### چرا `key` ها برای لیست‌ها ضروری هستن؟

موقع رندر کردن لیست‌ها، ری‌اکت از `key` ها برای ردیابی اینکه کدوم آیتم‌ها اضافه، حذف یا جابجا شدن استفاده می‌کنه:

```jsx
<ul>
  {items.map((item) => (
    <li key={item.id}>{item.text}</li>
  ))}
</ul>
```

بدون `key`، ری‌اکت فقط به موقعیت المنت در آرایه تکیه می‌کرد. اگه یه آیتم جدید به ابتدای لیست اضافه می‌کردید، ری‌اکت فکر می‌کرد **تمام** المنت‌ها تغییر کردن و کل لیست رو از نو رندر می‌کرد.

اما با `key`، ری‌اکت می‌تونه المنت‌ها رو بین رندرها، بدون توجه به موقعیتشون، با هم مچ کنه.

#### `key` خارج از آرایه‌ها؟

ری‌اکت شما رو مجبور نمی‌کنه برای المنت‌های استاتیک `key` بذارید:

```jsx
// نیازی به key نیست
<>
  <Input />
  <Input />
</>
```

این کد کار می‌کنه چون ری‌اکت می‌دونه این المنت‌ها استاتیک هستن و موقعیتشون در درخت قابل پیش‌بینیه.

اما `key` ها حتی خارج از لیست‌ها هم می‌تونن خیلی قدرتمند باشن. این مثال رو ببینید:

```jsx
const Component = () => {
  const [isReverse, setIsReverse] = useState(false);

  return (
    <>
      <Input key={isReverse ? "some-key" : null} />
      <Input key={!isReverse ? "some-key" : null} />
    </>
  );
};
```

وقتی `isReverse` تغییر می‌کنه، `key` به نام "some-key" از یک `Input` به اون یکی منتقل میشه و این باعث میشه ری‌اکت استیت کامپوننت رو بین دو موقعیت «جابجا» کنه!

#### ترکیب المنت‌های داینامیک و استاتیک

یک نگرانی رایج اینه که آیا اضافه کردن آیتم به یک لیست داینامیک، ممکنه هویت المنت‌های استاتیکی که بعد از اون لیست میان رو تغییر بده؟

```jsx
<>
  {items.map((item) => (
    <ListItem key={item.id} />
  ))}
  <StaticElement /> {/* آیا این با تغییر items دوباره ساخته میشه؟ */}
</>
```

ری‌اکت این موضوع رو هوشمندانه مدیریت می‌کنه. اون کل لیست داینامیک رو به عنوان **یک واحد** در موقعیت اول در نظر می‌گیره، بنابراین `StaticElement` همیشه موقعیت و هویت خودش رو حفظ می‌کنه، فارغ از تغییرات لیست.

اینطوری ری‌اکت این ساختار رو به صورت داخلی نمایش میده:

```javascript
[
  // کل آرایه داینامیک تبدیل به یک فرزند واحد میشه
  [
    { type: ListItem, key: "1" },
    { type: ListItem, key: "2" },
  ],
  // این همیشه موقعیت دوم خودش رو حفظ میکنه
  { type: StaticElement }, 
];
```

حتی اگه شما آیتم‌ها رو از لیست کم یا زیاد کنید، `StaticElement` در موقعیت دوم در آرایه والد باقی می‌مونه. این یعنی وقتی لیست تغییر می‌کنه، این کامپوننت دوباره ساخته (re-mount) نمیشه. این یک بهینه‌سازی هوشمندانه‌ست که تضمین می‌کنه المنت‌های استاتیک به خاطر تغییر در لیست‌های داینامیک مجاور، بی‌جهت دوباره ساخته نشن.

#### ۳. `key` برای کنترل استراتژیک DOM

`key` ها فقط برای لیست‌ها نیستن - ابزار قدرتمندی برای کنترل هویت کامپوننت و المنت‌های DOM در ری‌اکت هستن. برای حفظ استیت کامپوننت ری‌اکت در نماهای مختلف، یادتون باشه که `key` و **نوع کامپوننت** با هم کار می‌کنن - کامپوننت‌هایی با `key` یکسان اما نوع متفاوت، همچنان از بین میرن و دوباره ساخته میشن. در این موارد، بالا بردن استیت (lifting state up) معمولاً رویکرد بهتریه:

```jsx
// رویکرد بالا بردن استیت برای حفظ استیت در نماهای مختلف (اینجا key کمکی نمیکنه)
const TabContent = ({ activeTab }) => {
  // استیتی که باید بین تب‌ها حفظ بشه
  const [sharedState, setSharedState] = useState({ /* ... */ });

  return (
    <div>
      {activeTab === "profile" && (
        <ProfileTab state={sharedState} onStateChange={setSharedState} />
      )}
      {activeTab === "settings" && (
        <SettingsTab state={sharedState} onStateChange={setSharedState} />
      )}
      {/* بقیه تب‌ها */}
    </div>
  );
};
```

در این حالت حفظ کردن `key` کافی نبود چون نوع (و رفرنس) بین تب‌ها متفاوته.

اما به این مثال نگاه کنید که از `key` و کامپوننت‌های کنترل‌نشده (uncontrolled) استفاده می‌کنه:

```jsx
const UserForm = ({ userId }) => {
  // اینجا هیچ استیت ری‌اکتی وجود نداره - از input های کنترل نشده استفاده شده

  return (
    <form>
      <input
        key={userId}
        name="username"
        // input کنترل‌نشده با defaultValue به جای value
        defaultValue=""
      />
      {/* بقیه فیلدهای فرم */}
    </form>
  );
};
```

با دادن یک `key` بر اساس `userId` به این `input` کنترل‌نشده، ما تضمین می‌کنیم که هر وقت `userId` تغییر کنه، ری‌اکت یک المنت DOM کاملاً جدید بسازه. از اونجایی که استیت یک `input` کنترل‌نشده در خود DOM زندگی می‌کنه نه در استیت ری‌اکت، این کار به طور موثری `input` رو موقع سوییچ کردن بین کاربران مختلف ریست می‌کنه. در این مورد، `key` تمام چیزیه که نیاز دارید.

عجب چیزیه، نه؟

### هم‌مکانی استیت (State Colocation): یک الگوی قدرتمند پرفورمنس

هم‌مکانی استیت الگوییه که در اون استیت تا حد ممکن نزدیک به جایی که استفاده میشه نگهداری میشه. این رویکرد با اطمینان از اینکه فقط کامپوننت‌هایی که مستقیماً تحت تأثیر تغییرات استیت هستن آپدیت میشن، رندرهای مجدد غیرضروری رو به حداقل می‌رسونه.

این مثال رو در نظر بگیرید:

```jsx
// پرفورمنس ضعیف - کل اپ با تغییر فیلتر، دوباره رندر میشه
const App = () => {
  const [filterText, setFilterText] = useState("");
  const filteredUsers = users.filter(/* ... */);

  return (
    <>
      <SearchBox filterText={filterText} onChange={setFilterText} />
      <UserList users={filteredUsers} />
      <ExpensiveComponent /> {/* این کامپوننت سنگین هم بی‌جهت رندر میشه */}
    </>
  );
};
```

با هم‌مکانی کردن استیت فیلتر فقط با کامپوننت‌هایی که از اون استفاده می‌کنن:

```jsx
const UserSection = () => {
  const [filterText, setFilterText] = useState("");
  const filteredUsers = users.filter(/* ... */);

  return (
    <>
      <SearchBox filterText={filterText} onChange={setFilterText} />
      <UserList users={filteredUsers} />
    </>
  );
};

const App = () => {
  return (
    <>
      <UserSection />
      <ExpensiveComponent /> {/* حالا این دیگه بی‌جهت رندر نمیشه */}
    </>
  );
};
```

حالا وقتی فیلتر تغییر می‌کنه، فقط `UserSection` دوباره رندر میشه. این الگو نه تنها پرفورمنس رو بهبود میده، بلکه منجر به طراحی بهتر کامپوننت‌ها میشه.

### طراحی کامپوننت: بهینه‌سازی برای تغییر

بهینه‌سازی پرفورمنس اغلب یک مشکل در طراحی کامپوننته. اگر یک کامپوننت کارهای زیادی انجام بده، احتمال اینکه بی‌جهت دوباره رندر بشه بیشتره.

قبل از اینکه سریع برید سراغ `React.memo`، از خودتون بپرسید:
*   آیا این کامپوننت مسئولیت‌های ترکیبی داره؟
*   آیا استیت بیش از حد لازم به بالا منتقل شده؟

این طراحی مشکل‌دار رو ببینید که مسئولیت‌هاش قاطی شده:

```jsx
const ProductPage = ({ productId }) => {
  const [selectedSize, setSelectedSize] = useState("medium");
  const [quantity, setQuantity] = = useState(1);
  // ... کلی استیت دیگه

  return (
    <div>
      <ProductInfo /* ... */ />
      <ShippingOptions /* ... */ />
      <Reviews reviews={reviews} />
    </div>
  );
};
```

هر بار که سایز، تعداد یا روش ارسال تغییر می‌کنه، کل صفحه دوباره رندر میشه، از جمله بخش نظرات که هیچ ربطی به این تغییرات نداره.

یک طراحی بهتر، این نگرانی‌ها رو از هم جدا می‌کنه:

```jsx
const ProductPage = ({ productId }) => {
  return (
    <div>
      <ProductConfig productId={productId} />
      <ReviewsSection productId={productId} />
    </div>
  );
};

const ProductConfig = ({ productId }) => {
  // فقط استیت‌های مربوط به تنظیمات محصول
  const [selectedSize, setSelectedSize] = useState("medium");
  // ...
  return ( /* ... */ );
};

const ReviewsSection = ({ productId }) => {
  // فقط استیت مربوط به نظرات
  const [reviews, setReviews] = useState([]);
  // ...
  return <Reviews reviews={reviews} />;
};
```

این ساختار تضمین می‌کنه که تغییر سایز محصول، باعث رندر مجدد بخش نظرات نمیشه. **نیازی به memoization نیست - فقط مرزبندی خوب بین کامپوننت‌ها.**

### Reconciliation و معماری پاک (Clean Architecture)

این درک از Reconciliation کاملاً با اصول معماری پاک همسوئه:
*   **اصل تک مسئولیتی (Single Responsibility):** هر کامپوننت باید یک دلیل برای تغییر داشته باشه.
*   **وارونگی وابستگی (Dependency Inversion):** کامپوننت‌ها باید به انتزاعات وابسته باشن، نه پیاده‌سازی‌های مشخص.
*   **جداسازی رابط (Interface Segregation):** کامپوننت‌ها باید رابط‌های کاربری (props) حداقلی و متمرکز داشته باشن.

### راهنمای عملی

بر اساس این شیرجه عمیق در Reconciliation، اینا چندتا راهنمای عملی هستن:
*   تعریف کامپوننت‌ها رو **بیرون** از کامپوننت والد نگه دارید تا از ساخته شدن مجددشون جلوگیری کنید.
*   استیت رو به **پایین** منتقل کنید تا مرزهای رندر مجدد رو ایزوله کنید.
*   در یک موقعیت ثابت، از **انواع کامپوننت یکسان** استفاده کنید تا از unmount شدن جلوگیری بشه.
*   از `key` ها به صورت **استراتژیک** استفاده کنید - نه فقط برای لیست‌ها، بلکه هر زمان که می‌خواید هویت کامپوننت رو کنترل کنید.
*   موقع دیباگ کردن مشکلات رندر، در قالب **درخت المنت‌ها** و **هویت کامپوننت** فکر کنید.

### نتیجه‌گیری

فهمیدن الگوریتم Reconciliation ری‌اکت، «چرا»ی پشت بسیاری از الگوهای پرفورمنس ری‌اکت رو آشکار می‌کنه. این توضیح میده که چرا کامپوزیشن (ترکیب) انقدر خوب کار می‌کنه، چرا برای لیست‌ها به `key` نیاز داریم، و چرا تعریف کامپوننت داخل کامپوننت دیگه مشکل‌سازه.

این دانش به ما کمک می‌کنه تصمیمات معماری بهتری بگیریم که به طور طبیعی منجر به اپلیکیشن‌های ری‌اکت با پرفورمنس بالا میشن. به جای جنگیدن با الگوریتم Reconciliation ری‌اکت با استفاده بیش از حد از memoization، می‌تونیم با طراحی ساختارهای کامپوننتی که با نحوه شناسایی و آپدیت کامپوننت‌ها توسط ری‌اکت همسو هستن، باهاش همکاری کنیم.

دفعه بعدی که در حال بهینه‌سازی یک اپلیکیشن ری‌اکت بودید، به این فکر کنید که ساختار کامپوننت شما چطور بر پروسه Reconciliation تأثیر میذاره. گاهی اوقات، بهترین بهینه‌سازی، یک درخت کامپوننت ساده‌تر و متمرکزتره.

---
*شما چه الگوهایی رو برای کار با پروسه Reconciliation ری‌اکت موثرتر دیدید؟ دوست دارم تجربیات شما رو بشنوم!* 🤓
